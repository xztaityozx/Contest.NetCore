# ABC104 D We Love ABC
- A,B,C,?の4文字で構成される文字列Sがある
- SをA,B,Cのどれかにできるとき、前からABCになる組み合わせは何個あるかを求める問題
    - DP
- `dp[i][j] = i-1番目まででj個文字を選んでいるときの残りの文字を選ぶ組み合わせの数`
    - 式を立ててみる
    - ここで`N=|S|`とする
    - `dp[N][3] = 1` : N文字から3個選んでいる。あとは何もしないの1通りしかない
    - `dp[N][0~2] = 0` : N文字から0~2文字しか選んでいない。N文字見切っているので手遅れ0通りしかできない
    - `dp[i<N][3] = m * dp[i+1][3]` : すでに3個選んでいて、選ぶ余地はない。`m`は`S[i]`が`?`なら3それ以外なら1。
    - `dp[i<N[j=0~2] = m * dp[i+1][j] + k * dp[i+1][j+1]` : 3個選んでいないので選ばない(前半)、もしくは選ぶ(後半)ということができる
        - 選ばないなら組み合わせは`S[i]`が`?`なら3パターン増えて、それ以外なら1つ
        - 選ぶなら、`S[i]`が`?`もしくは`ABC`のうち`j`番目の文字なら選べるので1通り。それ以外なら0通り。
    - これを後ろからやっていくと答えが`dp[0][0]`に現れる。
```c#
public void Solve() {
    // ABC104 D
    var S = ReadLine();
    var N = S.Length;
    var dp = new Map<int,long>[N+1]; // dp[i][j]=i-1文字目まで処理していてj個選んでいるときの残りの文字の処理パターン数
    // dp[N][0~2] = 成立してないので0パターン, dp[N][3]=正常終了
    dp[N] = new Map<int, long> {[0] = 0, [1] = 0, [2] = 0, [3] = 1};
    var mask = "ABC_";

    Func<long, long> Mod = (x) => x % (long) (1e9 + 7);

    for (var i = N - 1; i >= 0; i--) {
        dp[i]=new Map<int, long>();
        foreach (var item in dp[i+1]) {
            var key = item.Key;
            
            var m = S[i] == '?' ? 3 : 1;
            var k = S[i] == '?' || S[i] == mask[key] ? 1 : 0;
            // すでに3つ選択しているのでやれることはない。組み合わせはS[i]が?なら3つ増える。それ以外は1つ
            if (key == 3) dp[i][3] = Mod(m * dp[i + 1][3]);
            // まだ3つ選択していないので選べる。ABCのうちkey番目の文字か?なら選べる。この文字を選ばないならパターンは上と同じ
            else dp[i][key] = Mod(Mod(m * dp[i + 1][key]) + Mod(k * dp[i + 1][key + 1]));
        }
    }
    
    dp[0][0].WL();


}
```